// Package stub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package stub

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
	BasicAuthScopes  = "BasicAuth.Scopes"
)

// Defines values for CryptoKeyMetaResponseAlgorithm.
const (
	CryptoKeyMetaResponseAlgorithmAES   CryptoKeyMetaResponseAlgorithm = "AES"
	CryptoKeyMetaResponseAlgorithmECDSA CryptoKeyMetaResponseAlgorithm = "ECDSA"
	CryptoKeyMetaResponseAlgorithmRSA   CryptoKeyMetaResponseAlgorithm = "RSA"
)

// Defines values for CryptoKeyMetaResponseType.
const (
	CryptoKeyMetaResponseTypePrivate   CryptoKeyMetaResponseType = "private"
	CryptoKeyMetaResponseTypePublic    CryptoKeyMetaResponseType = "public"
	CryptoKeyMetaResponseTypeSymmetric CryptoKeyMetaResponseType = "symmetric"
)

// Defines values for UploadKeyRequestAlgorithm.
const (
	UploadKeyRequestAlgorithmAES   UploadKeyRequestAlgorithm = "AES"
	UploadKeyRequestAlgorithmECDSA UploadKeyRequestAlgorithm = "ECDSA"
	UploadKeyRequestAlgorithmRSA   UploadKeyRequestAlgorithm = "RSA"
)

// Defines values for GetKeysParamsAlgorithm.
const (
	AES   GetKeysParamsAlgorithm = "AES"
	ECDSA GetKeysParamsAlgorithm = "ECDSA"
	RSA   GetKeysParamsAlgorithm = "RSA"
)

// Defines values for GetKeysParamsType.
const (
	GetKeysParamsTypePrivate   GetKeysParamsType = "private"
	GetKeysParamsTypePublic    GetKeysParamsType = "public"
	GetKeysParamsTypeSymmetric GetKeysParamsType = "symmetric"
)

// Defines values for GetKeysParamsSortOrder.
const (
	Asc  GetKeysParamsSortOrder = "asc"
	Desc GetKeysParamsSortOrder = "desc"
)

// BlobMetaResponse defines model for BlobMetaResponse.
type BlobMetaResponse struct {
	DateTimeCreated   time.Time `json:"dateTimeCreated"`
	EncryptionKeyID   *string   `json:"encryptionKeyID,omitempty"`
	Id                string    `json:"id"`
	Name              string    `json:"name"`
	SignKeyID         *string   `json:"signKeyID,omitempty"`
	SignatureBlobID   *string   `json:"signatureBlobID,omitempty"`
	SignatureFileName *string   `json:"signatureFileName,omitempty"`
	Size              int64     `json:"size"`
	Type              string    `json:"type"`
	UserID            string    `json:"userID"`
}

// CryptoKeyMetaResponse defines model for CryptoKeyMetaResponse.
type CryptoKeyMetaResponse struct {
	Algorithm       CryptoKeyMetaResponseAlgorithm `json:"algorithm"`
	DateTimeCreated time.Time                      `json:"dateTimeCreated"`
	Id              string                         `json:"id"`
	KeyPairID       string                         `json:"keyPairID"`
	KeySize         uint32                         `json:"keySize"`
	Type            CryptoKeyMetaResponseType      `json:"type"`
	UserID          string                         `json:"userID"`
}

// CryptoKeyMetaResponseAlgorithm defines model for CryptoKeyMetaResponse.Algorithm.
type CryptoKeyMetaResponseAlgorithm string

// CryptoKeyMetaResponseType defines model for CryptoKeyMetaResponse.Type.
type CryptoKeyMetaResponseType string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Message *string `json:"message,omitempty"`
}

// InfoResponse defines model for InfoResponse.
type InfoResponse struct {
	Message *string `json:"message,omitempty"`
}

// UploadKeyRequest defines model for UploadKeyRequest.
type UploadKeyRequest struct {
	Algorithm UploadKeyRequestAlgorithm `json:"algorithm"`
	KeySize   int                       `json:"key_size"`
}

// UploadKeyRequestAlgorithm defines model for UploadKeyRequest.Algorithm.
type UploadKeyRequestAlgorithm string

// BlobId defines model for BlobId.
type BlobId = string

// KeyId defines model for KeyId.
type KeyId = string

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// GetBlobsParams defines parameters for GetBlobs.
type GetBlobsParams struct {
	Name            *string    `form:"name,omitempty" json:"name,omitempty"`
	Size            *int64     `form:"size,omitempty" json:"size,omitempty"`
	Type            *string    `form:"type,omitempty" json:"type,omitempty"`
	DateTimeCreated *time.Time `form:"dateTimeCreated,omitempty" json:"dateTimeCreated,omitempty"`
	Limit           *Limit     `form:"limit,omitempty" json:"limit,omitempty"`
	Offset          *Offset    `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostBlobsMultipartBody defines parameters for PostBlobs.
type PostBlobsMultipartBody struct {
	EncryptionKeyId *string            `json:"encryption_key_id,omitempty"`
	Files           openapi_types.File `json:"files"`
	SignKeyId       *string            `json:"sign_key_id,omitempty"`
}

// GetBlobsIdFileParams defines parameters for GetBlobsIdFile.
type GetBlobsIdFileParams struct {
	DecryptionKeyId *string `form:"decryption_key_id,omitempty" json:"decryption_key_id,omitempty"`
}

// GetKeysParams defines parameters for GetKeys.
type GetKeysParams struct {
	Algorithm       *GetKeysParamsAlgorithm `form:"algorithm,omitempty" json:"algorithm,omitempty"`
	Type            *GetKeysParamsType      `form:"type,omitempty" json:"type,omitempty"`
	DateTimeCreated *time.Time              `form:"dateTimeCreated,omitempty" json:"dateTimeCreated,omitempty"`
	Limit           *Limit                  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset          *Offset                 `form:"offset,omitempty" json:"offset,omitempty"`
	SortBy          *string                 `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	SortOrder       *GetKeysParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// GetKeysParamsAlgorithm defines parameters for GetKeys.
type GetKeysParamsAlgorithm string

// GetKeysParamsType defines parameters for GetKeys.
type GetKeysParamsType string

// GetKeysParamsSortOrder defines parameters for GetKeys.
type GetKeysParamsSortOrder string

// PostBlobsMultipartRequestBody defines body for PostBlobs for multipart/form-data ContentType.
type PostBlobsMultipartRequestBody PostBlobsMultipartBody

// PostKeysJSONRequestBody defines body for PostKeys for application/json ContentType.
type PostKeysJSONRequestBody = UploadKeyRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List blob metadata
	// (GET /blobs)
	GetBlobs(c *gin.Context, params GetBlobsParams)
	// Upload a blob with optional encryption and signing
	// (POST /blobs)
	PostBlobs(c *gin.Context)
	// Delete blob by ID
	// (DELETE /blobs/{id})
	DeleteBlobsId(c *gin.Context, id BlobId)
	// Get blob metadata by ID
	// (GET /blobs/{id})
	GetBlobsId(c *gin.Context, id BlobId)
	// Download blob file
	// (GET /blobs/{id}/file)
	GetBlobsIdFile(c *gin.Context, id BlobId, params GetBlobsIdFileParams)
	// Download blob signature
	// (GET /blobs/{id}/signature)
	GetBlobsIdSignature(c *gin.Context, id BlobId)
	// List cryptographic keys
	// (GET /keys)
	GetKeys(c *gin.Context, params GetKeysParams)
	// Upload cryptographic keys
	// (POST /keys)
	PostKeys(c *gin.Context)
	// Delete key by ID
	// (DELETE /keys/{id})
	DeleteKeysId(c *gin.Context, id KeyId)
	// Get key metadata by ID
	// (GET /keys/{id})
	GetKeysId(c *gin.Context, id KeyId)
	// Download key file (PEM format)
	// (GET /keys/{id}/file)
	GetKeysIdFile(c *gin.Context, id KeyId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetBlobs operation middleware
func (siw *ServerInterfaceWrapper) GetBlobs(c *gin.Context) {

	var err error

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlobsParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", c.Request.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter size: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "dateTimeCreated" -------------

	err = runtime.BindQueryParameter("form", true, false, "dateTimeCreated", c.Request.URL.Query(), &params.DateTimeCreated)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dateTimeCreated: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBlobs(c, params)
}

// PostBlobs operation middleware
func (siw *ServerInterfaceWrapper) PostBlobs(c *gin.Context) {

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostBlobs(c)
}

// DeleteBlobsId operation middleware
func (siw *ServerInterfaceWrapper) DeleteBlobsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id BlobId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBlobsId(c, id)
}

// GetBlobsId operation middleware
func (siw *ServerInterfaceWrapper) GetBlobsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id BlobId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBlobsId(c, id)
}

// GetBlobsIdFile operation middleware
func (siw *ServerInterfaceWrapper) GetBlobsIdFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id BlobId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlobsIdFileParams

	// ------------- Optional query parameter "decryption_key_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "decryption_key_id", c.Request.URL.Query(), &params.DecryptionKeyId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter decryption_key_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBlobsIdFile(c, id, params)
}

// GetBlobsIdSignature operation middleware
func (siw *ServerInterfaceWrapper) GetBlobsIdSignature(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id BlobId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBlobsIdSignature(c, id)
}

// GetKeys operation middleware
func (siw *ServerInterfaceWrapper) GetKeys(c *gin.Context) {

	var err error

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeysParams

	// ------------- Optional query parameter "algorithm" -------------

	err = runtime.BindQueryParameter("form", true, false, "algorithm", c.Request.URL.Query(), &params.Algorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "dateTimeCreated" -------------

	err = runtime.BindQueryParameter("form", true, false, "dateTimeCreated", c.Request.URL.Query(), &params.DateTimeCreated)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dateTimeCreated: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sortBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortBy", c.Request.URL.Query(), &params.SortBy)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sortBy: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sortOrder" -------------

	err = runtime.BindQueryParameter("form", true, false, "sortOrder", c.Request.URL.Query(), &params.SortOrder)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sortOrder: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetKeys(c, params)
}

// PostKeys operation middleware
func (siw *ServerInterfaceWrapper) PostKeys(c *gin.Context) {

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostKeys(c)
}

// DeleteKeysId operation middleware
func (siw *ServerInterfaceWrapper) DeleteKeysId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id KeyId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteKeysId(c, id)
}

// GetKeysId operation middleware
func (siw *ServerInterfaceWrapper) GetKeysId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id KeyId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetKeysId(c, id)
}

// GetKeysIdFile operation middleware
func (siw *ServerInterfaceWrapper) GetKeysIdFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id KeyId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BasicAuthScopes, []string{})

	c.Set(ApiKeyAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetKeysIdFile(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/blobs", wrapper.GetBlobs)
	router.POST(options.BaseURL+"/blobs", wrapper.PostBlobs)
	router.DELETE(options.BaseURL+"/blobs/:id", wrapper.DeleteBlobsId)
	router.GET(options.BaseURL+"/blobs/:id", wrapper.GetBlobsId)
	router.GET(options.BaseURL+"/blobs/:id/file", wrapper.GetBlobsIdFile)
	router.GET(options.BaseURL+"/blobs/:id/signature", wrapper.GetBlobsIdSignature)
	router.GET(options.BaseURL+"/keys", wrapper.GetKeys)
	router.POST(options.BaseURL+"/keys", wrapper.PostKeys)
	router.DELETE(options.BaseURL+"/keys/:id", wrapper.DeleteKeysId)
	router.GET(options.BaseURL+"/keys/:id", wrapper.GetKeysId)
	router.GET(options.BaseURL+"/keys/:id/file", wrapper.GetKeysIdFile)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
